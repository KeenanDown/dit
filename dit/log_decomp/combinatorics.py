"""
Tools for extracting combinatorial results. Tools for computing upper sets.
For more information, see the preprint.
https://arxiv.org/abs/2305.07554
"""
# Specify all functions defined in this module.
__all__=[
    'upper_set',
    'get_n_atoms'
]

# Do some imports.
from ..npdist import Distribution

def upper_set(dist, generators):
    """
    Given a collection of generator atoms 'generators', compute the upper set
    in the inclusion lattice. E.g. 1 <= 12 <= 123.

    Paramaters
    ----------
    dist : dit.Distribution
        The distribution to be analysed.
    generators : set, list, tuple
        A set or list of generator atoms. If a tuple, then a single generating atom.

    Returns
    -------
    upper_set_out : set
        A set of atoms forming an upper set, generated by 'generators'.

    Notes
    -----
    For more information, see the preprint.
    https://arxiv.org/abs/2305.07554
    """
    # Check the inputs are the correct types.
    if not isinstance(dist, Distribution):
        raise TypeError("'dist' must be a dit distribution.")
    elif not isinstance(generators, (set, list, tuple)):
        raise TypeError("'generators' must be a set, list, or a tuple for a single atom.")
    # Get all of the outcomes from the distribution.
    outcomes = dist.outcomes
    # If given a tuple, make it a list.
    if isinstance(generators, tuple):
        generators = [generators]
    # Initialise an intermediate
    upper_set_intermediate = set(generators)
    # For each outcome, add it to each element and append to the upper_set. Repeat.
    for outcome in outcomes:
        # Initialise the set to add.
        upper_set_additional = set()
        # For each element in the upper set:
        for x in upper_set_intermediate:
            # Convert the tuple to a list.
            x_list =list(x)
            # Test that the outcome wasn't already in x.
            if outcome not in x_list:
                x_list.append(outcome)
            x = tuple(x_list)
            # Add the result to the new set.
            upper_set_additional.add(x)
        # Add the new set to the old
        upper_set_intermediate.update(upper_set_additional)
    # Now take the intermediate set and convert everything to sets.
    upper_set_second = set()
    for x in upper_set_intermediate:
        upper_set_second.add(frozenset(x))
    # Finally convert these back to tuples. These two will remove duplicates.
    upper_set_out = set()
    for x in upper_set_second:
        upper_set_out = upper_set_out.union({tuple(x)})
    return upper_set_out

def get_n_atoms(atoms, n = 2):
    """
    Extract the n-atoms from the set or list 'atoms'.

    Parameters
    ----------
    atoms : set, list
        A set or list of atoms (tuples) to extract from.
    n : int, string
        The size of atoms to extract.
        If 'even', then extracts all even atoms. Likewise for 'odd'.
    
    Returns
    -------
    n_atoms : set
        A set of n-atoms inside of 'atoms'.

    Notes
    -----
    For more information, see the preprint.
    https://arxiv.org/abs/2305.07554
    """
    # Check the inputs are the correct types.
    if not isinstance(atoms, (set, list)):
        raise TypeError("'atoms' must be a set or a list.")
    if not isinstance(n, (int, str)):
        raise TypeError("'n' must be an integer, 'even' or 'odd'.")
    if isinstance(n, str):
        if n not in ["even", "odd"]:
            raise ValueError("'n' must be either an integer, 'even' or 'odd'.")
    # Create the set to output.
    if isinstance(n, int):
        n_atoms = {atom for atom in atoms if len(atom) == n}
    elif n == "even":
        n_atoms = {atom for atom in atoms if len(atom) % 2 == 0}
    elif n == "odd":
        n_atoms = {atom for atom in atoms if len(atom) % 2 == 1}
    # Return this.
    return n_atoms
